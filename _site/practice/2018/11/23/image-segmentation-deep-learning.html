<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Page metadata --> 
  <!-- Reference: http://jovandeginste.github.io/2016/05/18/add-metadata-tags-to-jekyll-blog-posts.html -->
  <meta name="description" content="안녕하세요! 딥러닝을 이용한 Detection 문제 해결 포스팅에 이어, 정말 오랜만에 이미지 인식 Segmentation에 관한 문제 해결 사례를 소개해드리도록 하겠습니다. 이번 포스팅도 앞선 포스팅과 마찬가지로 TensorFlow 구현 코드와 함께 진행됩니다. Segmentat...">

  <meta property="og:site_name" content="Cognex Deep Learning Lab-KOR Research Blog">
  
  <meta property="og:title" content="이미지 Segmentation 문제와 딥러닝: GCN으로 개 고양이 분류 및 분할하기">
  <meta property="og:type" content="article">
  <meta property="og:description" content="안녕하세요! 딥러닝을 이용한 Detection 문제 해결 포스팅에 이어, 정말 오랜만에 이미지 인식 Segmentation에 관한 문제 해결 사례를 소개해드리도록 하겠습니다. 이번 포스팅도 앞선 포스팅과 마찬가지로 TensorFlow 구현 코드와 함께 진행됩니다. Segmentation의 경우 많은 시간 및 메모리를 소모하며 설명자료가 Classification 문제에 비해 많지 않아 어렵게 느껴질 수도 있지만, Segmentation은 Pixel-wise classification으로 생각할 수 있기 때문에 구현 자체 난이도는 Classification과 크게 다르지 않습니다. 다소 난해한 Detection에 비해 금방 이해할 수 있으리라 생각하며, 이전 포스팅과 마찬가지로 개념적인 설명은 조금 뒤로하고 구현 위주로 설명해 드리도록 하겠습니다.

"/>
  
  
  <meta property="article:published_time" content="2018-11-23T09:00:00+09:00">
  <meta property="article:author" content="http://github.sualab.io/about/">
  
  <meta property="og:url" content="http://github.sualab.io/practice/2018/11/23/image-segmentation-deep-learning.html" />
  
  <meta itemprop="keywords" content="segmentation,GCN,tensorflow" />
  
  <meta property="article:tag" content="segmentation">
  
  <meta property="article:tag" content="GCN">
  
  <meta property="article:tag" content="tensorflow">
  
  
  
  <!-- end of Page metadata -->

  <title>이미지 Segmentation 문제와 딥러닝: GCN으로 개 고양이 분류 및 분할하기</title>
  <meta name="description" content="안녕하세요! 딥러닝을 이용한 Detection 문제 해결 포스팅에 이어, 정말 오랜만에 이미지 인식 Segmentation에 관한 문제 해결 사례를 소개해드리도록 하겠습니다. 이번 포스팅도 앞선 포스팅과 마찬가지로 TensorFlow 구현 코드와 함께 진행됩니다. Segmentat...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://github.sualab.io/practice/2018/11/23/image-segmentation-deep-learning.html">  <link rel="alternate" type="application/rss+xml" title="Cognex Deep Learning Lab-KOR Research Blog" href="/feed.xml">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

  <!-- Enabling line-breaking for MathJax equations -->
  <!-- @reference: https://stackoverflow.com/questions/29893923/how-to-make-formula-with-mathjax-responsive/29904718 -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
       "HTML-CSS": { linebreaks: { automatic: true } },
                SVG: { linebreaks: { automatic: true } }
                });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-110963421-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-110963421-1');
</script>


  
</head>
<body><header class="site-header" role="banner">

<div class="wrapper">
  
  
	<div class="cognex-logo-div">
		<img class="cognex-logo-img" src="/assets/images/Cognex_logo.png" />
	</div>
	<div>
  	<a class="site-title" href="/">Cognex Deep Learning Lab-KOR Research Blog</a>
	</div>

  
    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
        </svg></span>
      </label>

      <div class="trigger">
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
          
          
        
	<a class="page-link" href="/Introduction.html"> Introduction </a>
	<a class="page-link" href="/Practice.html"> Practice </a>
	<a class="page-link" href="/Development.html"> Development </a>
	<a class="page-link" href="/Review.html"> Review </a>
	<a class="page-link" href="/etc..html"> etc. </a>
  <a class="page-link" href="https://jobs.cognex.com/" target="_blank"> Jobs </a>
      </div>
    </nav>
  
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <!-- Look the author details up from the site config. -->

<!-- Post metadata -->
<!-- Reference: http://jovandeginste.github.io/2016/05/18/add-metadata-tags-to-jekyll-blog-posts.html -->

<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">이미지 Segmentation 문제와 딥러닝: GCN으로 개 고양이 분류 및 분할하기</h1>
    <p class="post-meta">
      <time datetime="2018-11-23T09:00:00+09:00" itemprop="datePublished">
        
        Nov 23, 2018
      </time>
       • 
        
          <span itemprop="category" itemscope itemtype="http://schema.org/Category"><a href="/Practice.html">Practice</a></span>
        
      
      
        • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name"><a href="https://github.com/JongsooKeum" target="_blank">금종수</a></span></span>
        <!-- Author metadata -->
        <meta itemprop="email" content="Jongsoo.Keum@cognex.com" />
        <meta itemprop="web" content="https://github.com/JongsooKeum" />
        <!-- end of Author metadata -->
      
      
         <br>Tags: segmentation, GCN, tensorflow
      
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>안녕하세요! 딥러닝을 이용한 Detection 문제 해결 포스팅에 이어, 정말 오랜만에 이미지 인식 <strong>Segmentation</strong>에 관한 문제 해결 사례를 소개해드리도록 하겠습니다. 이번 포스팅도 앞선 포스팅과 마찬가지로 <strong>TensorFlow</strong> 구현 코드와 함께 진행됩니다. Segmentation의 경우 많은 시간 및 메모리를 소모하며 설명자료가 Classification 문제에 비해 많지 않아 어렵게 느껴질 수도 있지만, Segmentation은 <strong>Pixel-wise classification</strong>으로 생각할 수 있기 때문에 구현 자체 난이도는 Classification과 크게 다르지 않습니다. 다소 난해한 Detection에 비해 금방 이해할 수 있으리라 생각하며, 이전 포스팅과 마찬가지로 개념적인 설명은 조금 뒤로하고 <strong>구현 위주</strong>로 설명해 드리도록 하겠습니다.</p>

<ul>
  <li><strong>다음과 같은 사항을 알고 계시면 더 이해하기 쉽습니다.</strong>
    <ul>
      <li>딥러닝에 대한 전반적인 이해</li>
      <li>Python 언어 및 TensorFlow 프레임워크에 대한 이해</li>
    </ul>
  </li>
  <li>이번 글에서 구현한 GCN(Global Convolutional Network)의 경우, 논문에서 명시된 것처럼 ResNet을 자체적으로 변형하여 학습한 pre-trained model을 사용하지 않고, 학습방법을 단순화하여 성능이 논문과 상이할 가능성이 있습니다.</li>
  <li>이번 글에서는 과거 Classification 구현체와 마찬가지로 데이터셋(data set), 성능 평가(performance evaluation), 러닝 모델(learning model), 러닝 알고리즘(learning algorithm) 4가지 요소를 나눠 구현하였으며, 중복을 피하고자 다르게 구현한 부분 위주로 설명합니다.
    <ul>
      <li>전체 구현체 코드는 <a href="https://github.com/sualab/tf-segmentation" target="_blank">수아랩의 GitHub 저장소</a>에서 자유롭게 확인하실 수 있습니다.</li>
      <li>본 글에서 사용한 개vs고양이 데이터셋은 <a href="http://www.robots.ox.ac.uk/~vgg/data/pets/" target="_blank">이곳</a>에서 다운로드 받으실 수 있습니다. 참고로, 받은 데이터셋이 데이터 로드 중에 깨지거나 너무 크기가 큰 이미지들이 존재하여, 이를 제거하고 사용하였습니다.</li>
      <li>제가 전처리한 데이터셋은 <a href="https://drive.google.com/file/d/1SD30E3Fj3216kHy_k71r5g_AG_uF1HRI/view?usp=sharing" target="_blank">여기</a>서 받을 수 있습니다.</li>
    </ul>
  </li>
</ul>

<h2 id="서론">서론</h2>

<p><a href="http://github.sualab.io/computer-vision/2017/11/29/image-recognition-overview-1.html" target="_blank">이미지 인식 문제의 개요: PASCAL VOC Challenge를 중심으로</a>에서 언급한 바와 같이, <strong>PASCAL VOC challenge</strong>에서 중요하게 다루는 3가지 이미지 인식 문제 중 Classification, Detection 이어서 마지막으로 <strong>Segmentation</strong> 기술로 해결할 수 있는 간단한 사례를 소개하고, 이를 딥러닝 기술 중 <strong>Encoder-Decoder 구조</strong> 중 널리 알려진 <strong>GCN(Global Convolutional Network)</strong> 망을 통해 해결하는 과정을 설명드리겠습니다.</p>

<p>앞서 말씀드린 것과 같이 이번 포스팅은 개념적인 설명부터 시작하면 지나치게 글이 길어지고 집중도가 떨어질 것 같아 Detection 포스팅과 마찬가지로 (1) 딥러닝 및 머신러닝에 대한 어느정도의 이해와, (2) Python 언어 및 TensorFlow 프레임워크에 대한 이해, 그리고 (3) Semantic Segmentation 알고리즘에 대한 전반적인 이해를 알고 있다는 전제하에 글을 쓰겠습니다. 글을 읽다가 이해가 안되는 부분이 있다면 다른곳에 좋은 글이 많이 있으니 숙지하신 후 읽어보시길 권장해 드립니다.</p>

<p>본 포스팅에서 해결할 Segmentation 문제는 Classification때와 비슷하게 개와 고양이를 분류, 분할하는 문제로 선택하였습니다. 뒤에서 살펴보겠지만, 한 이미지에 단 하나의 개 혹은 고양이 하나의 객체만 존재하기 때문에, <strong>Cityscape</strong> 혹은 <strong>PASCAL VOC challenge</strong> 보다 해결할 문제가 훨씬 쉬운 편입니다. 하지만, 즉각적으로 구현한 모델이 어느 정도 정상적으로 작동하는지 확인하기 좋고 구현을 통해 Segmentation 문제를 이해하는 데 부족함이 없어 채택하였습니다.</p>

<p><strong>개 vs 고양이 분할</strong> 문제를 해결하기 위한 딥러닝 알고리즘으로는 <strong>Encoder-Decoder</strong>계열의 <strong>GCN</strong>(<strong>Global Convolutional Network</strong>)를 채택하였습니다. 공개된 Segmentation(TensorFlow) 구현체의 경우, DeepLab으로 대표되는 <strong>Dilated convolution(Atrous convolution)</strong> 계열이 대부분입니다. Dilated convolution 계열의 경우 성능적으로 우수하나, 많은 메모리를 잡아먹고 속도 면에서 좋지 않은 경우가 많습니다. 추가로, DeepLab 계열은 TensorFlow 자체에 구현체가 있으므로 공부하기가 편하나, Encoder-Decoder 계열은 상대적으로 구현체가 적어 차별화(?)를 위해 <strong>GCN</strong>을 선택하였습니다.</p>

<p>GCN 구현체는 앞선 <a href="http://github.sualab.io/machine-learning/computer-vision/2018/01/17/image-classification-deep-learning.html" target="_blank">Classification 문제</a>와 같이 데이터셋(data set), 성능 평가(performance evaluation), 러닝 모델(learning model), 러닝 알고리즘(learning algorithm) 4가지 요소를 중심으로 작성하였으며, 이전 포스팅과 겹치지 않은 부분 위주로 소개해드리겠습니다.</p>

<h2 id="1-데이터셋-개vs고양이">(1) 데이터셋: 개vs고양이</h2>

<p>개vs고양이 분류 문제를 위해 사용한 데이터셋은 <a href="http://www.robots.ox.ac.uk/~vgg/data/pets/" target="_blank">The Oxford-IIIT Pet Dataset</a>에서 가져왔습니다. 가져온 데이터셋의 정보를 모두 사용하려고 하였으나, 파일을 읽어들일 때 깨지는 경우와, 해상도가 1000 이상으로 큰 경우가 있어 약간의 처리를 거친 후 남은 이미지를 사용하였습니다. (깨진 이미지 제거, 해상도 600 이상 제거)</p>

<p>데이터를 저장해두는 방식은 무수히 많지만, 이번 포스팅 예제에서는 원본을 해치지 않는 선에서 다음과 같은 형식으로 진행하도록 하겠습니다.</p>
<ul>
  <li>이미지(jpg)마다 매칭되는 <strong>mask</strong> 이미지(png)를 가집니다. ex) Bombay_217.jpg &lt;–&gt; Bombay_217.png</li>
  <li>mask 이미지는 세가지 값 (1:Foreground, 2:Background, 3:Unknown)을 가지며, 각 파일명의 영어 부분은 개 혹은 고양의 종 이름을 나타내며, 맨 앞글자가 대문자면 고양이 그렇지 않으면 개를 나타냅니다. 이번 포스팅에서는 크게 <strong>개와 고양이만을 분류, 분할하는 문제</strong>로 간소화 하겠습니다.</li>
  <li>폴더에 images 폴더, masks 폴더를 두고 images 폴더에 이미지를, masks 폴더에 mask 이미지를 넣어둡니다.</li>
</ul>

<!-- @reference: https://www.kevinmcgillivray.net/captions-for-images-with-jekyll/ -->
<p><a href="http://github.sualab.io/assets/images/image-segmentation-deep-learning/example.png" target="_blank">
  <img class="full-image" src="http://github.sualab.io/assets/images/image-segmentation-deep-learning/example.png" alt="개vs고양이 데이터셋 예시" />
</a>
<span class="caption">개vs고양이 데이터셋 예시</span></p>

<p>데이터셋은 총 4,817장으로 이중 임의로 10%를 골라 480장을 테스트셋으로 사용하였습니다. 클래스는 “개”, “고양이” 두 가지로 객체가 있을 곳을 예측하여 배경과 분할하는 문제로 진행됩니다.</p>

<h3 id="datasetsdata-모듈">datasets.data 모듈</h3>

<p><code class="language-plaintext highlighter-rouge">datasets.data</code> 모듈은 데이터셋에 관련된 함수와 클래스를 가지고 있습니다. Classification 문제때와 마찬가지로, 이 모듈은 데이터셋을 메모리에 로드하고 학습 및 예측평가 과정에서 미니배치(minibatch) 단위로 제공해주는 역할을 합니다.</p>

<h4 id="read_data-함수">read_data 함수</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">read_data</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="n">no_label</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="s">"""
    Segmentation문제를 위해 데이터를 전처리하고 로드.
    :param data_dir: image 및 mask 데이터가 저장된 root 경로
    :image_size: tuple, 크롭 및 패딩을 위해 지정된 이미지 사이즈
    :no_label: bool, 레이블을 로드할 지 여부
    :return: X_set: np.ndarray, shape: (N, H, W, C).
             y_set: np.ndarray, shape: (N, H, W, num_classes (include background)).
    """</span>
    <span class="n">im_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">EXT</span><span class="p">:</span>
        <span class="n">im_paths</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s">'images'</span><span class="p">,</span> <span class="s">'*.{}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>
    <span class="n">imgs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">im_path</span> <span class="ow">in</span> <span class="n">im_paths</span><span class="p">:</span>
        <span class="c1">#이미지 로드
</span>        <span class="n">im_name</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">basename</span><span class="p">(</span><span class="n">im_path</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">im_path</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">crop_shape</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)</span>
        <span class="n">imgs</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">no_label</span><span class="p">:</span>
            <span class="n">labels</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1">#마스크 로드
</span>        <span class="n">mask_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_dir</span><span class="p">,</span> <span class="s">'masks'</span><span class="p">,</span> <span class="s">'{}.png'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">im_name</span><span class="p">))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">cv2</span><span class="p">.</span><span class="n">imread</span><span class="p">(</span><span class="n">mask_path</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">crop_shape</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">image_size</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">padding</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">image_size</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">label</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">image_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">image_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">label</span><span class="p">.</span><span class="n">fill</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Pixel annotations 1:Foreground, 2:Background, 3:Unknown
</span>        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">label</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">im_name</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">isupper</span><span class="p">():</span>
            <span class="n">label</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">labels</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

    <span class="n">X_set</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">y_set</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">X_set</span><span class="p">,</span> <span class="n">y_set</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">load_data</code> 함수는 위의 형식으로 저장된 데이터셋을 불러와 각 이미지를 Crop 혹은 Padding을 통해 원하는 크기로 맞춘 뒤, <code class="language-plaintext highlighter-rouge">np.ndarray</code> 형태로 반환합니다. 마찬가지로 mask 이미지를 불러와 각 픽셀에 대해 one-hot encoding된 label을 <code class="language-plaintext highlighter-rouge">np.ndarray</code> 형태로 반환합니다. 만약 이미지 사이즈가 \(512 \times 512\)이라면 <code class="language-plaintext highlighter-rouge">y_set</code>의 형태는 <code class="language-plaintext highlighter-rouge">(N, 512, 512, class 개수 (background 포함))</code>로 표현됩니다.</p>

<h4 id="dataset-클래스">DataSet 클래스</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DataSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">images</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s">"""
        새로운 DataSet 객체를 생성함.
        :param images: np.ndarray, shape: (N, H, W, C)
        :param labels: np.ndarray, shape: (N, H, W, num_classes (include background)).
        """</span>
        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">images</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">labels</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>\
                <span class="p">(</span><span class="s">'Number of examples mismatch, between images and labels'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_num_examples</span> <span class="o">=</span> <span class="n">images</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_images</span> <span class="o">=</span> <span class="n">images</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_labels</span> <span class="o">=</span> <span class="n">labels</span>  <span class="c1"># NOTE: this can be None, if not given.
</span>        <span class="c1"># image/label indices(can be permuted)
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_num_examples</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">uint</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""일부 변수를 재설정함."""</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_epochs_completed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_index_in_epoch</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">images</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_images</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_labels</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">num_examples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_num_examples</span>

    <span class="k">def</span> <span class="nf">sample_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="s">"""
        'batch_size' 개수만큼 데이터들을 현재 데이터셋으로부터 추출하여 미니배치 형태로 '한번' 반환함.
        :param batch_size: int,  미니배치 크기
        :param shuffle: bool, 추출 이전에, 데이터셋 이미지를 섞을지 여부
        :return: batch_images: np.ndarray, shape: (N, H, W, C)
                 batch_labels: np.ndarray, shape: (N, H, W, num_classes (include background))
        """</span>

        <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">choice</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_num_examples</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">arange</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">batch_images</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_images</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">batch_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">batch_labels</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">batch_images</span><span class="p">,</span> <span class="n">batch_labels</span>

    <span class="k">def</span> <span class="nf">next_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="s">"""
        'batch_size' 개수만큼 데이터들을 현재 데이터셋으로부터 추출하여 미니배치 형태로 반환함.
        :param batch_size: int, 미니배치 크기
        :param shuffle: bool, 추출 이전에, 데이터셋 이미지를 섞을지 여부
        :return: batch_images: np.ndarray, shape: (N, H, W, C)
                 batch_labels: np.ndarray, shape: (N, H, W, num_classes (include background))
        """</span>

        <span class="n">start_index</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_index_in_epoch</span>

        <span class="c1"># 맨 첫 번째 epoch에서 전체 데이터셋을 랜덤하게 섞음
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">_epochs_completed</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">start_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">shuffle</span><span class="p">:</span>
            <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_indices</span><span class="p">)</span>

        <span class="c1"># 현재의 인덱스가 전체 이미지 수를 넘어간 경우, 다음 epoch을 진행함
</span>        <span class="k">if</span> <span class="n">start_index</span> <span class="o">+</span> <span class="n">batch_size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">_num_examples</span><span class="p">:</span>
            <span class="c1"># epochs 수를 1 증가
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">_epochs_completed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># 새로운 epoch에서, 남은 데이터들을 가져옴
</span>            <span class="n">rest_num_examples</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_num_examples</span> <span class="o">-</span> <span class="n">start_index</span>
            <span class="n">indices_rest_part</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_indices</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span><span class="bp">self</span><span class="p">.</span><span class="n">_num_examples</span><span class="p">]</span>

            <span class="c1"># epoch가 끝나면, 데이터를 섞음
</span>            <span class="k">if</span> <span class="n">shuffle</span><span class="p">:</span>
                <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_indices</span><span class="p">)</span>

            <span class="c1"># 다음 epoch 진행
</span>            <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_index_in_epoch</span> <span class="o">=</span> <span class="n">batch_size</span> <span class="o">-</span> <span class="n">rest_num_examples</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_index_in_epoch</span>
            <span class="n">indices_new_part</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_indices</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span><span class="n">end_index</span><span class="p">]</span>

            <span class="n">images_rest_part</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_images</span><span class="p">[</span><span class="n">indices_rest_part</span><span class="p">]</span>
            <span class="n">images_new_part</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_images</span><span class="p">[</span><span class="n">indices_new_part</span><span class="p">]</span>
            <span class="n">batch_images</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span><span class="n">images_rest_part</span><span class="p">,</span> <span class="n">images_new_part</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">labels_rest_part</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">indices_rest_part</span><span class="p">]</span>
                <span class="n">labels_new_part</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">indices_new_part</span><span class="p">]</span>
                <span class="n">batch_labels</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">labels_rest_part</span><span class="p">,</span> <span class="n">labels_new_part</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">batch_labels</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_index_in_epoch</span> <span class="o">+=</span> <span class="n">batch_size</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_index_in_epoch</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_indices</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span><span class="n">end_index</span><span class="p">]</span>
            <span class="n">batch_images</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_images</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">batch_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_labels</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">batch_labels</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="n">batch_images</span><span class="p">,</span> <span class="n">batch_labels</span>
</code></pre></div></div>

<p>Classification 문제때와 마찬가지로 <code class="language-plaintext highlighter-rouge">DataSet</code> 클래스를 이용하여 메모리에 로드된 <code class="language-plaintext highlighter-rouge">X_set</code>과 <code class="language-plaintext highlighter-rouge">y_set</code>을 미니배치(minibatch) 단위로 반환해 줍니다.</p>

<h3 id="2-성능-평가-pixel-accuracy">(2) 성능 평가: Pixel Accuracy</h3>

<p>모델의 분할 성능 평가를 위해 <strong>Pixel Accuracy</strong>를 사용합니다. Segmentation에서는 mIoU(mean Intersection over union)가 가장 빈번하게 사용되는 성능 척도이나, 이미지에서 객체의 크기가 크고 한가지 밖에 없는 편이라 굳이 IoU까지 사용할 필요가 없다고 판단하여 Pixel Accuracy를 성능 평가 척도로 사용하였습니다. 이는 이미지 단위에서 전체 pixel 개수 대비 올바르게 분류한 pixel의 수로 정의됩니다.</p>

<p>\begin{equation}
\text{Pixel Accuracy} = \frac{\text{올바르게 분류한 Pixel의 수}} {\text{전체 Pixel의 수}}
\end{equation}</p>

<h3 id="learningevaluators-모듈">learning.evaluators 모듈</h3>

<p>Classification 문제와 마찬가지로, 성능 평가를 위한 <code class="language-plaintext highlighter-rouge">evaluator</code> 클래스를 담고 있습니다.</p>

<h4 id="evaluator-클래스">Evaluator 클래스</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Evaluator</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="s">"""성능 평가를 위한 evaluator의 베이스 클래스."""</span>

    <span class="o">@</span><span class="n">abstractproperty</span>
    <span class="k">def</span> <span class="nf">worst_score</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        최저 성능 점수.
        :return float.
        """</span>
        <span class="k">pass</span>

    <span class="o">@</span><span class="n">abstractproperty</span>
    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        점수가 높아야 성능이 우수한지, 낮아야 성능이 우수한지 여부. 'max'와 'min' 중 하나.
        e.g. 정확도, AUC, 정밀도, 재현율 등의 경우 'max',
             오류율, 미검률, 오검률 등의 경우 'min'.
        :return: str.
        """</span>
        <span class="k">pass</span>

    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
        <span class="s">"""
        실제로 사용할 성능 평가 지표.
        해당 함수를 추후 구현해야 함.
        :param y_true: np.ndarray, shape: (N, num_classes).
        :param y_pred: np.ndarray, shape: (N, num_classes).
        :return float.
        """</span>
        <span class="k">pass</span>

    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">is_better</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="n">best</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        현재 주어진 성능 점수가 현재까지의 최고 성능 점수보다 우수한지 여부를 반환하는 함수.
        해당 함수를 추후 구현해야 함.
        :param curr: float, 평가 대상이 되는 현재 성능 점수.
        :param best: float, 현재까지의 최고 성능 점수.
        :return bool.
        """</span>
        <span class="k">pass</span>
</code></pre></div></div>

<p>추상 베이스 클래스입니다. 다른 부분은 모두 Classification 문제에서 서술한 내용과 같아 추가 설명은 생략하겠습니다.</p>

<h4 id="accuracyevaluator-클래스">AccuracyEvaluator 클래스</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AccuracyEvaluator</span><span class="p">(</span><span class="n">Evaluator</span><span class="p">):</span>
  <span class="s">""" Pixel Accuracy를 성능 평가 척도로 사용하는 evaluator 클래스"""</span>
    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">worst_score</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""최저 성능 점수"""</span>
        <span class="k">return</span> <span class="mf">0.0</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""점수가 높아야 성능이 우수한지 낮아야 우수한지 여부"""</span>
        <span class="k">return</span> <span class="s">'max'</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
        <span class="s">"""주어진 예측 마스크 이미지에 대해 Pixel Accuracy를 계산"""</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">):</span>
            <span class="c1"># Unknown 영역은 제외하고 pixel accuracy 계산
</span>            <span class="n">ignore</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span><span class="p">[...,</span><span class="mi">0</span><span class="p">].</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">acc</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">accuracy_score</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">ignore</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                      <span class="n">np</span><span class="p">.</span><span class="n">delete</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">).</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">ignore</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">is_better</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="n">best</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        상대적 문턱값을 고려하여, 현재 주어진 성능 점수가 현재까지의 최고 성능 점수보다
        우수한지 여부를 반환하는 함수.
        :param kwargs: dict, 추가 인자.
            - score_threshold: float, 새로운 최적값 결정을 위한 상대적 문턱값으로,
                               유의미한 차이가 발생했을 경우만을 반영하기 위함.
        """</span>
        <span class="n">score_threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'score_threshold'</span><span class="p">,</span> <span class="mf">1e-4</span><span class="p">)</span>
        <span class="n">relative_eps</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">score_threshold</span>
        <span class="k">return</span> <span class="n">curr</span> <span class="o">&gt;</span> <span class="n">best</span> <span class="o">*</span> <span class="n">relative_eps</span>
</code></pre></div></div>

<p>Pixel Accuracy를 성능 평가 척도로 사용하기 위해 상속받아 <code class="language-plaintext highlighter-rouge">AccuracyEvaluator</code> 클래스를 구현하였습니다. 앞서 설명했듯이, 다루는 데이터셋의 경우 Unknown region이 있기 때문에 Pixel accuracy를 계산할 때 Unknown region은 계산에 포함되지 않도록 정의하고 계산하였습니다. Accuracy는 0.0부터 1.0까지 나타날 수 있으며, 높을 수록 좋은 성능 척도이기 때문에, <code class="language-plaintext highlighter-rouge">mode</code>를 ‘max’로, <code class="language-plaintext highlighter-rouge">score_threshold</code> 값을 1e-4로 설정하였습니다.</p>

<h2 id="러닝-모델-gcnglobal-convolutional-network">러닝 모델: GCN(Global Convolutional Network)</h2>

<p>러닝 모델로는 앞서 말씀드린 GCN을 사용합니다. Detection때와 마찬가지로 주로 사용하는 층(layers)들을 생성하는 함수를 <code class="language-plaintext highlighter-rouge">models.layers</code> 모듈에서 정의하고, <code class="language-plaintext highlighter-rouge">models.nn</code> 모듈에서 일반적인 Segmentation용 컨볼루션 신경망 모델을 정의하고 GCN 클래스가 상속받는 형식으로 구현하였습니다.</p>

<h3 id="modelslayers-모듈">models.layers 모듈</h3>

<p><code class="language-plaintext highlighter-rouge">models.layers</code> 모듈은 classification 문제때와 다르게, <code class="language-plaintext highlighter-rouge">tf.layers</code> 모듈을 사용하여 간편하게 convolution layer를 재정의했으며, 이외에 GCN을 구현할 때 필요한 layer인 boundary refine layer와, global convolutional layer 그리고 upscale layer를 추가하였습니다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">conv_layer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="s">'SAME'</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tf</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">conv2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="n">use_bias</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">up_scale</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="s">"""feature map의 크기를 bilinear upsampling을 통해 2배 키움"""</span>
    <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span> <span class="n">tf</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">image</span><span class="p">.</span><span class="n">resize_bilinear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">dtype</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">boundary_refine_module</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">filters</span><span class="p">):</span>
    <span class="s">"""
    see: Large Kernel Matters -- Improve Semantic Segmentation by Global Convolutional Network
    https://arxiv.org/abs/1703.02719
    """</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">conv_layer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">relu</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">conv_layer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">c2</span>

<span class="k">def</span> <span class="nf">global_conv_module</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">):</span>
    <span class="s">"""
    see: Large Kernel Matters -- Improve Semantic Segmentation by Global Convolutional Network
    https://arxiv.org/abs/1703.02719
    """</span>
    <span class="n">kl</span> <span class="o">=</span> <span class="n">kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">kr</span> <span class="o">=</span> <span class="n">kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">l1</span> <span class="o">=</span> <span class="n">conv_layer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="p">(</span><span class="n">kl</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">conv_layer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">kr</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">l2</span> <span class="o">=</span> <span class="n">conv_layer</span><span class="p">(</span><span class="n">l1</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">kr</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">conv_layer</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="p">(</span><span class="n">kl</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">l2</span> <span class="o">+</span> <span class="n">r2</span>   
</code></pre></div></div>

<h3 id="modelsnn-모듈">models.nn 모듈</h3>

<p><code class="language-plaintext highlighter-rouge">models.nn</code> 모듈은 마찬가지로 신경망을 표현하는 클래스를 가지고 있습니다.</p>

<h4 id="segnet-클래스">SegNet 클래스</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SegNet</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="s">"""Segmentation을 위한 컨볼루션 신경망 모델의 베이스 클래스."""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_shape</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        모델 생성자.
        :param input_shape: tuple, shape (H, W, C)
        :param num_classes: int, 총 클래스 개수
        """</span>
        <span class="k">if</span> <span class="n">input_shape</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">input_shape</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">,</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">input_shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">placeholder</span><span class="p">(</span>
            <span class="n">tf</span><span class="p">.</span><span class="n">int32</span><span class="p">,</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">input_shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">num_classes</span><span class="p">])</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">is_train</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="n">num_classes</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_build_model</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">pred</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="s">'pred'</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="s">'logits'</span><span class="p">]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">loss</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_build_loss</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_build_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        모델 생성.
        해당 함수를 추후 구현해야 함.
        """</span>
        <span class="k">pass</span>

    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_build_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        모델 학습을 위한 손실 함수 생성.
        해당 함수를 추후 구현해야 함.
        """</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        주어진 데이터셋에 대한 예측을 수행함.
        :param sess: tf.Session.
        :param dataset: DataSet.
        :param verbose: bool, 예측 과정에서 구체적인 정보를 출력할지 여부.
        :param kwargs: dict, 예측을 위한 추가 인자.
                -batch_size: int, 각 반복 회차에서의 미니배치 크기.
        :return _y_pred: np.ndarray, shape: (N, H, W, num_classes) 
        """</span>

        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'batch_size'</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>

        <span class="n">num_classes</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">num_classes</span>
        <span class="n">pred_size</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">.</span><span class="n">num_examples</span>
        <span class="n">num_steps</span> <span class="o">=</span> <span class="n">pred_size</span> <span class="o">//</span> <span class="n">batch_size</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Running prediction loop...'</span><span class="p">)</span>

        <span class="c1"># Start prediction loop
</span>        <span class="n">_y_pred</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">num_steps</span><span class="p">:</span>
                <span class="n">_batch_size</span> <span class="o">=</span> <span class="n">pred_size</span> <span class="o">-</span> <span class="n">num_steps</span> <span class="o">*</span> <span class="n">batch_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">.</span><span class="n">next_batch</span><span class="p">(</span>
                <span class="n">_batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="c1"># Compute predictions
</span>            <span class="c1"># (N, H, W, num_classes)
</span>            <span class="n">y_pred</span> <span class="o">=</span> <span class="n">sess</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">pred</span><span class="p">,</span> <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span>
                              <span class="bp">self</span><span class="p">.</span><span class="n">X</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">is_train</span><span class="p">:</span> <span class="bp">False</span><span class="p">})</span>
            <span class="n">_y_pred</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_pred</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Total prediction time(sec): {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span>
                <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">))</span>

        <span class="n">_y_pred</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">_y_pred</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_y_pred</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">SegNet</code> 클래스는 , 기본 추상 베이스 클래스로, 확장성을 위해 전반적인 Segmentation Network를 포괄하도록 구현하였습니다. <code class="language-plaintext highlighter-rouge">_build_model</code> 과 <code class="language-plaintext highlighter-rouge">_build_loss</code> 함수는 <code class="language-plaintext highlighter-rouge">SegNet</code>의 자식 클래스에서 구현하도록 하였고, <code class="language-plaintext highlighter-rouge">predict</code> 함수는 모델의 예측 결과를 반환합니다. 보통 Segmentation의 경우 Detection과 다르게 architecture를 구축하는 부분을 제외하고 loss 등은 크게 변하지 않습니다. 추상 클래스를 잘 정의해두면 지금 구현하는 GCN뿐만 아니라 다양한 Segmentation architecuture를 큰 시간 소비없이 손쉽게 구현할 수 있을 것이라 생각합니다!</p>

<!-- @reference: https://www.kevinmcgillivray.net/captions-for-images-with-jekyll/ -->
<p><a href="http://github.sualab.io/assets/images/image-segmentation-deep-learning/overview_gcn.png" target="_blank">
  <img class="full-image" src="http://github.sualab.io/assets/images/image-segmentation-deep-learning/overview_gcn.png" alt="GCN Architecture" />
</a>
<span class="caption">GCN Architecture</span></p>

<h4 id="gcn-클래스">GCN 클래스</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GCN</span><span class="p">(</span><span class="n">SegNet</span><span class="p">):</span>
    <span class="s">"""
    GCN class
    see: Large Kernel Matters -- Improve Semantic Segmentation by Global Convolutional Network
    https://arxiv.org/abs/1703.02719
    """</span>
    <span class="k">def</span> <span class="nf">_build_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        모델 생성
        :param kwargs: dict, GCN 생성을 위한 추가 인자.
                -pretrain: bool, pretrain 모델을 쓸지 말지 결정.
                -frontend: string, 불러올 pretrained model 이름.
        :return d: dict, 각 층에서의 출력값들을 포함함
        """</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">num_classes</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">num_classes</span>
        <span class="n">pretrain</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'pretrain'</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">frontend</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'frontend'</span><span class="p">,</span> <span class="s">'resnet_v2_50'</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">pretrain</span><span class="p">:</span>
            <span class="n">frontend_dir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s">'pretrained_models'</span><span class="p">,</span> <span class="s">'{}.ckpt'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">frontend</span><span class="p">))</span>
            <span class="k">with</span> <span class="n">slim</span><span class="p">.</span><span class="n">arg_scope</span><span class="p">(</span><span class="n">resnet_v2</span><span class="p">.</span><span class="n">resnet_arg_scope</span><span class="p">()):</span>
                <span class="n">logits</span><span class="p">,</span> <span class="n">end_points</span> <span class="o">=</span> <span class="n">resnet_v2</span><span class="p">.</span><span class="n">resnet_v2_50</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">is_training</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">is_train</span><span class="p">)</span>
                <span class="n">d</span><span class="p">[</span><span class="s">'init_fn'</span><span class="p">]</span> <span class="o">=</span> <span class="n">slim</span><span class="p">.</span><span class="n">assign_from_checkpoint_fn</span><span class="p">(</span><span class="n">model_path</span><span class="o">=</span><span class="n">frontend_dir</span><span class="p">,</span>
                                                              <span class="n">var_list</span><span class="o">=</span><span class="n">slim</span><span class="p">.</span><span class="n">get_model_variables</span><span class="p">(</span><span class="n">frontend</span><span class="p">))</span>
                <span class="n">resnet_dict</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s">'/block1/unit_2/bottleneck_v2'</span><span class="p">,</span>  <span class="c1"># conv1
</span>                <span class="s">'/block2/unit_3/bottleneck_v2'</span><span class="p">,</span>  <span class="c1"># conv2
</span>                <span class="s">'/block3/unit_5/bottleneck_v2'</span><span class="p">,</span>  <span class="c1"># conv3
</span>                <span class="s">'/block4/unit_3/bottleneck_v2'</span>   <span class="c1"># conv4
</span>                <span class="p">]</span>
                <span class="n">convs</span> <span class="o">=</span> <span class="p">[</span><span class="n">end_points</span><span class="p">[</span><span class="n">frontend</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">resnet_dict</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO build convNet
</span>            <span class="k">raise</span> <span class="nb">NotImplementedError</span><span class="p">(</span><span class="s">"Build own convNet!"</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># input size should be bigger than (512, 512)
</span>            <span class="n">g_kernel_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g_kernel_size</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">value</span><span class="o">//</span><span class="mi">32</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">X</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="n">value</span><span class="o">//</span><span class="mi">32</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="n">variable_scope</span><span class="p">(</span><span class="s">'layer5'</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'gcm1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">global_conv_module</span><span class="p">(</span><span class="n">convs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">g_kernel_size</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'brm1_1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_refine_module</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'gcm1'</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'up16'</span><span class="p">]</span> <span class="o">=</span> <span class="n">up_scale</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'brm1_1'</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="n">variable_scope</span><span class="p">(</span><span class="s">'layer4'</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'gcm2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">global_conv_module</span><span class="p">(</span><span class="n">convs</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">g_kernel_size</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'brm2_1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_refine_module</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'gcm2'</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'sum16'</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s">'up16'</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="s">'brm2_1'</span><span class="p">]</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'brm2_2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_refine_module</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'sum16'</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'up8'</span><span class="p">]</span> <span class="o">=</span> <span class="n">up_scale</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'brm2_2'</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="n">variable_scope</span><span class="p">(</span><span class="s">'layer3'</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'gcm3'</span><span class="p">]</span> <span class="o">=</span> <span class="n">global_conv_module</span><span class="p">(</span><span class="n">convs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">g_kernel_size</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'brm3_1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_refine_module</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'gcm3'</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'sum8'</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s">'up8'</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="s">'brm3_1'</span><span class="p">]</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'brm3_2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_refine_module</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'sum8'</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'up4'</span><span class="p">]</span> <span class="o">=</span> <span class="n">up_scale</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'brm3_2'</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="n">variable_scope</span><span class="p">(</span><span class="s">'layer2'</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'gcm4'</span><span class="p">]</span> <span class="o">=</span> <span class="n">global_conv_module</span><span class="p">(</span><span class="n">convs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">,</span> <span class="n">g_kernel_size</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'brm4_1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_refine_module</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'gcm4'</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'sum4'</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s">'up4'</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="s">'brm4_1'</span><span class="p">]</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'brm4_2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_refine_module</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'sum4'</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'up2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">up_scale</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'brm4_2'</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="n">variable_scope</span><span class="p">(</span><span class="s">'layer1'</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'brm4_3'</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_refine_module</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'up2'</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'up1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">up_scale</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'brm4_3'</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'brm4_4'</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_refine_module</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'up1'</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="n">variable_scope</span><span class="p">(</span><span class="s">'output_layer'</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'logits'</span><span class="p">]</span> <span class="o">=</span> <span class="n">conv_layer</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'brm4_4'</span><span class="p">],</span> <span class="n">num_classes</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">d</span><span class="p">[</span><span class="s">'pred'</span><span class="p">]</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s">'logits'</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">_build_loss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        모델 학습을 위한 손실 함수 생성
        :return tf.Tensor.
        """</span>
        <span class="c1"># pixel-wise cross entropy loss를 계산하고 unknown 영역을 무시
</span>        <span class="n">ignore</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">[...,</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">softmax_loss</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">nn</span><span class="p">.</span><span class="n">softmax_cross_entropy_with_logits_v2</span><span class="p">(</span>
                        <span class="n">labels</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">logits</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">logits</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">softmax_loss</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tf</span><span class="p">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span>

</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">GCN</code> 모델은 pretrained model에서 encoding된 압축된 feature map을 원래 이미지 크기로 decoding하면서 segmentation map을 생성하고 각 pixel마다 클래스를 분류하여 이미지를 분할합니다. GCN(Global convolutional Network)은 이름 그대로 pixel을 예측할 때 global하게 보기 위하여 kernel 사이즈를 이미지 전체만큼 가져가며 (\(512 \times 512\)의 경우 \(15 \times 15\)) 이를 정제하는 방식으로 decoding 합니다. 첨부한 모식도를 보시면 보다 더 쉽게 이해하실 수 있을 것 같습니다.</p>

<p>손실 함수의 경우 classification때와 마찬가지로 cross entropy loss를 사용합니다. Classification에서 image 단위로 cross entropy를 계산했다면, Segmentation에서는 pixel 단위로 cross entropy를 계산하여 사용합니다. 사용하는 데이터셋의 경우 Unknown region이 있기 때문에, Unknown pixel은 loss 계산에서 제외하는 방식으로 손실 함수를 정의하였습니다.</p>

<p>추가로, Background에 비해 Foreground 영역이 작아 imbalance한 경우 그리고 binary segmentation인 경우, 1-Dice coefficient 혹은 1-IoU를 손실함수로 사용할 수도 있습니다. 풀고자하는 문제가 위와 같다면 한번 손실함수를 재정의해서 학습에 사용해보시는 것도 추천 드립니다.</p>

<p>** 제가 구현한 GCN의 경우 resnetv2-50(slim ver.) pretrained model을 사용합니다. 제공된 구현체를 수정없이 돌려보시려면 <a href="https://github.com/tensorflow/models/tree/master/research/slim" target="_blank">여기</a>에 들어가서 pretrained model을 받은 후, <em>pretrained_models</em> 폴더에 체크포인트(.ckpt)파일을 넣어두시면 됩니다! 추가로, 자기만의 Convolutional network를 구현하거나 다른 pretrained model도 사용해보시길 권장드립니다.</p>

<h2 id="4-러닝-알고리즘-sgdmomentum">(4) 러닝 알고리즘: SGD+Momentum</h2>

<p>러닝 알고리즘은 Classification 문제 그리고 Detection 문제때와 크게 다르지 않습니다. <strong>모멘텀(momentum)</strong>을 적용한 <strong>확률적 경사 하강법(stochastic gradient descent; 이하 SGD)</strong>을 채택하였으며, 베이스 클래스를 먼저 정의한 뒤, 이를 모멘텀 SGD에 기반한 optimizer 클래스가 상속받는 형태로 구현하였습니다. Pretrained model weights를 불러오는 부분을 제외하고 Detection 포스팅 때와 동일하니 설명은 생략하도록 하겠습니다.</p>

<h3 id="learningoptimizers-모듈">learning.optimizers 모듈</h3>

<h4 id="optimizer-클래스">Optimizer 클래스</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Optimizer</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="s">"""경사 하강 러닝 알고리즘 기반 optimizer의 베이스 클래스"""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">train_set</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">,</span> <span class="n">val_set</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        Optimizer 생성자.
        :param model: Net, 학습할 모델.
        :param train_set: DataSet, 학습에 사용할 학습 데이터셋.
        :param evaluator: Evaluator, 학습 수행 과정에서 성능 평가에 사용할 evaluator.
        :param val_set: Datset, 검증 데이터셋, 주어지지 않은 경우 None으로 남겨둘 수 있음.
        :param kwargs: dict, 학습 관련 하이퍼파라미터로 구성된 추가 인자.
                - batch_size: int, 각 반복 회차에서의 미니배치 크기.
                - num_epochs: int, 총 epoch 수.
                - init_learning_rate: float, 학습률 초기값.
        """</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">train_set</span> <span class="o">=</span> <span class="n">train_set</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">evaluator</span> <span class="o">=</span> <span class="n">evaluator</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">val_set</span> <span class="o">=</span> <span class="n">val_set</span>

        <span class="c1"># 학습 관련 하이퍼파라미터
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'batch_size'</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">num_epochs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'num_epochs'</span><span class="p">,</span> <span class="mi">300</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">init_learning_rate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'init_learning_rate'</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">learning_rate_placeholder</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">placeholder</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">optimize</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_optimize_op</span><span class="p">()</span>

        <span class="bp">self</span><span class="p">.</span><span class="n">_reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""일부 변수를 재설정."""</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">curr_epoch</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># number of bad epochs, where the model is updated without improvement.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">num_bad_epochs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># initialize best score with the worst one
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">best_score</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">evaluator</span><span class="p">.</span><span class="n">worst_score</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">curr_learning_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">init_learning_rate</span>

    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_optimize_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        경사 하강 업데이트를 위한 tf.train.Optimizer.minimize Op.
        해당 함수를 추후 구현해야 하며, 외부에서 임의로 호출할 수 없음.
        """</span>
        <span class="k">pass</span>

    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">_update_learning_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        고유의 학습률 스케줄링 방법에 따라, (필요한 경우) 매 epoch마다 현 학습률 값을 업데이트함.
        해당 함수를 추후 구현해야 하며, 외부에서 임의로 호출할 수 없음.
        """</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        경사 하강 업데이트를 1회 수행하며, 관련된 값을 반환함.
        해당 함수를 추후 구현해야 하며, 외부에서 임의로 호출할 수 없음.
        :param sess, tf.Session.
        :return loss: float, 1회 반복 회차 결과 손실 함수값.
                y_true: np.ndarray, 학습 데이터셋의 실제 레이블.
                y_pred: np.ndarray, 모델이 반환한 예측 레이블.
        """</span>

        <span class="c1"># 미니배치 하나를 추출함
</span>        <span class="n">X</span><span class="p">,</span> <span class="n">y_true</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">train_set</span><span class="p">.</span><span class="n">next_batch</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c1"># 손실 함수값을 계산하고, 모델 업데이트를 수행.
</span>        <span class="n">_</span><span class="p">,</span> <span class="n">loss</span><span class="p">,</span> <span class="n">y_pred</span> <span class="o">=</span> \
            <span class="n">sess</span><span class="p">.</span><span class="n">run</span><span class="p">([</span><span class="bp">self</span><span class="p">.</span><span class="n">optimize</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">loss</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">pred_y</span><span class="p">],</span>
                     <span class="n">feed_dict</span><span class="o">=</span><span class="p">{</span><span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">X</span><span class="p">:</span> <span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">y</span><span class="p">:</span> <span class="n">y_true</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">is_train</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">learning_rate_placeholder</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">curr_learning_rate</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">loss</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">,</span> <span class="n">X</span>

    <span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sess</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="s">'/tmp'</span><span class="p">,</span> <span class="n">details</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        Optimizer를 실행하고, 모델을 학습함.
        :param sess: tf.Session.
        :param save_dir: str, 학습된 모델의 파라미터들을 저장할 디렉터리 경로.
        :param details: bool, 학습 결과 관련 구체적인 정보를, 학습 종료 후 반환할지 여부.
        :param verbose: bool, 학습 과정에서 구체적인 정보를 출력할지 여부.
        :param kwargs: dict, 학습 관련 하이퍼파라미터로 구성된 추가 인자.
        :return train_results: dict, 구체적인 학습 결과를 담은 dict
        """</span>
        <span class="n">saver</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">train</span><span class="p">.</span><span class="n">Saver</span><span class="p">()</span>
        <span class="n">sess</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">global_variables_initializer</span><span class="p">())</span>  <span class="c1"># 전체 파라미터들을 초기화함
</span>        
        <span class="c1"># pretrained weight를 가져옴
</span>        <span class="k">if</span> <span class="s">'init_fn'</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">d</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Load pretrained weights...'</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">d</span><span class="p">[</span><span class="s">'init_fn'</span><span class="p">](</span><span class="n">sess</span><span class="p">)</span>
            
        <span class="n">train_results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">train_size</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">train_set</span><span class="p">.</span><span class="n">num_examples</span>
        <span class="n">num_steps_per_epoch</span> <span class="o">=</span> <span class="n">train_size</span> <span class="o">//</span> <span class="bp">self</span><span class="p">.</span><span class="n">batch_size</span>
        <span class="n">num_steps</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">num_epochs</span> <span class="o">*</span> <span class="n">num_steps_per_epoch</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Running training loop...'</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Number of training iterations: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">num_steps</span><span class="p">))</span>

        <span class="n">step_losses</span><span class="p">,</span> <span class="n">step_scores</span><span class="p">,</span> <span class="n">eval_scores</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>

        <span class="c1"># 학습 루프를 실행함
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_steps</span><span class="p">):</span>
            <span class="c1"># 미니배치 하나로부터 경사 하강 업데이트를 1회 수행함
</span>            <span class="n">step_loss</span><span class="p">,</span> <span class="n">step_y_true</span><span class="p">,</span> <span class="n">step_y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_step</span><span class="p">(</span><span class="n">sess</span><span class="p">)</span>
            <span class="n">step_losses</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">step_loss</span><span class="p">)</span>
            <span class="c1"># 매 epoch의 말미에서, 성능 평가를 수행함
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="n">num_steps_per_epoch</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># 학습 데이터셋으로부터 추출한 현재의 미니배치에 대하여 모델의 예측 성능을 평가함
</span>                <span class="n">step_score</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">evaluator</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">step_y_true</span><span class="p">,</span> <span class="n">step_y_pred</span><span class="p">)</span>
                <span class="n">step_scores</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">step_score</span><span class="p">)</span>

                <span class="c1"># 검증 데이터셋이 주어진 경우, 이를 사용하여 모델 성능을 평가함
</span>                <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">val_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c1"># 검증 데이터셋을 사용하여 모델 성능을 평가함
</span>                    <span class="n">eval_y_pred</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span>
                        <span class="n">sess</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">val_set</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">eval_score</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">evaluator</span><span class="p">.</span><span class="n">score</span><span class="p">(</span>
                        <span class="bp">self</span><span class="p">.</span><span class="n">val_set</span><span class="p">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">eval_y_pred</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">eval_scores</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">eval_score</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="c1"># 중간 결과를 출력함
</span>                        <span class="k">print</span><span class="p">(</span><span class="s">'[epoch {}]</span><span class="se">\t</span><span class="s">loss: {:.6f} |Train score: {:.6f} |Eval score: {:.6f} |lr: {:.6f}'</span>
                              <span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">curr_epoch</span><span class="p">,</span> <span class="n">step_loss</span><span class="p">,</span> <span class="n">step_score</span><span class="p">,</span> <span class="n">eval_score</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">curr_learning_rate</span><span class="p">))</span>
                        <span class="c1"># 중간 결과를 플롯팅함
</span>                        <span class="n">plot_learning_curve</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">step_losses</span><span class="p">,</span> <span class="n">step_scores</span><span class="p">,</span> <span class="n">eval_scores</span><span class="o">=</span><span class="n">eval_scores</span><span class="p">,</span>
                                            <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">evaluator</span><span class="p">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">img_dir</span><span class="o">=</span><span class="n">save_dir</span><span class="p">)</span>

                    <span class="n">curr_score</span> <span class="o">=</span> <span class="n">eval_score</span>
                <span class="c1"># 그렇지 않은 경우, 단순히 미니배치에 대한 결과를 사용하여 모델 성능을 평가함
</span>                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="c1"># 중간 결과를 출력함
</span>                        <span class="k">print</span><span class="p">(</span><span class="s">'[epoch {}]</span><span class="se">\t</span><span class="s">loss: {:.6f} |Train score: {:.6f} |lr: {:.6f}'</span>\
                            <span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">curr_epoch</span><span class="p">,</span> <span class="n">step_loss</span><span class="p">,</span> <span class="n">step_score</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">curr_learning_rate</span><span class="p">))</span>
                        <span class="c1"># 중간 결과를 플롯팅함
</span>                        <span class="n">plot_learning_curve</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">step_losses</span><span class="p">,</span> <span class="n">step_scores</span><span class="p">,</span> <span class="n">eval_scores</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                                            <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">evaluator</span><span class="p">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">img_dir</span><span class="o">=</span><span class="n">save_dir</span><span class="p">)</span>

                    <span class="n">curr_score</span> <span class="o">=</span> <span class="n">step_score</span>

                <span class="c1"># 현재의 성능 점수의 현재까지의 최고 성능 점수를 비교하고,
</span>                <span class="c1"># 최고 성능 점수가 갱신된 경우 해당 성능을 발휘한 모델의 파라미터들을 저장함
</span>                <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">evaluator</span><span class="p">.</span><span class="n">is_better</span><span class="p">(</span><span class="n">curr_score</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">best_score</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">best_score</span> <span class="o">=</span> <span class="n">curr_score</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">num_bad_epochs</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">saver</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_dir</span><span class="p">,</span> <span class="s">'model.ckpt'</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">num_bad_epochs</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="bp">self</span><span class="p">.</span><span class="n">_update_learning_rate</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">curr_epoch</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Total training time(sec): {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span>
                <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">))</span>
            <span class="k">print</span><span class="p">(</span><span class="s">'Best {} score: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span>
                <span class="s">'evaluation'</span> <span class="k">if</span> <span class="nb">eval</span> <span class="k">else</span> <span class="s">'training'</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">best_score</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Done.'</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">details</span><span class="p">:</span>
            <span class="c1"># 학습 결과를 dict에 저장함
</span>            <span class="n">train_results</span><span class="p">[</span><span class="s">'step_losses'</span><span class="p">]</span> <span class="o">=</span> <span class="n">step_losses</span>
            <span class="n">train_results</span><span class="p">[</span><span class="s">'step_scores'</span><span class="p">]</span> <span class="o">=</span> <span class="n">step_scores</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">val_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">train_results</span><span class="p">[</span><span class="s">'eval_scores'</span><span class="p">]</span> <span class="o">=</span> <span class="n">eval_scores</span>

            <span class="k">return</span> <span class="n">train_results</span>
</code></pre></div></div>

<h4 id="momentumoptimizer-클래스">MomentumOptimizer 클래스</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MomentumOptimizer</span><span class="p">(</span><span class="n">Optimizer</span><span class="p">):</span>
    <span class="s">"""모멘텀 알고리즘을 포함한 경사 하강 optimizer 클래스."""</span>

    <span class="k">def</span> <span class="nf">_optimize_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        경사 하강 업데이트를 위한 tf.train.MomentumOptimizer.minimize Op.
       :param kwargs: dict, optimizer의 추가 인자.
                -momentum: float, 모멘텀 계수.
        :return tf.Operation.
        """</span>
        <span class="n">momentum</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'momentum'</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">)</span>
        <span class="n">extra_update_ops</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">get_collection</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">GraphKeys</span><span class="p">.</span><span class="n">UPDATE_OPS</span><span class="p">)</span>
        <span class="n">update_vars</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">trainable_variables</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">tf</span><span class="p">.</span><span class="n">control_dependencies</span><span class="p">(</span><span class="n">extra_update_ops</span><span class="p">):</span>
            <span class="n">train_op</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">train</span><span class="p">.</span><span class="n">AdamOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">learning_rate_placeholder</span><span class="p">,</span> <span class="n">momentum</span><span class="p">).</span><span class="n">minimize</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="p">.</span><span class="n">loss</span><span class="p">,</span> <span class="n">var_list</span><span class="o">=</span><span class="n">update_vars</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">train_op</span>

    <span class="k">def</span> <span class="nf">_update_learning_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""
        성능 평가 점수 상에 개선이 없을 때, 현 학습률 값을 업데이트함.
        :param kwargs: dict, 학습률 스케줄링을 위한 추가 인자.
            - learning_rate_patience: int, 성능 향상이 연속적으로 이루어지지 않은 epochs 수가 
                                      해당 값을 초과할 경우, 학습률 값을 감소시킴.
            - learning_rate_decay: float, 학습률 업데이트 비율.
            - eps: float, 업데이트된 학습률 값과 기존 학습률 값 간의 차이가 해당 값보다 작을 경우,
                          학습률 업데이트를 취소함.
        """</span>
        <span class="n">learning_rate_patience</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'learning_rate_patience'</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">learning_rate_decay</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'learning_rate_decay'</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'eps'</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">num_bad_epochs</span> <span class="o">&gt;</span> <span class="n">learning_rate_patience</span><span class="p">:</span>
            <span class="n">new_learning_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">curr_learning_rate</span> <span class="o">*</span> <span class="n">learning_rate_decay</span>
            <span class="c1"># 새 학습률 값과 기존 학습률 값 간의 차이가 eps보다 큰 경우에 한해서만 업데이트를 수행함
</span>            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">curr_learning_rate</span> <span class="o">-</span> <span class="n">new_learning_rate</span> <span class="o">&gt;</span> <span class="n">eps</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">curr_learning_rate</span> <span class="o">=</span> <span class="n">new_learning_rate</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">num_bad_epochs</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></div>

<h2 id="학습-수행-및-테스트-결과">학습 수행 및 테스트 결과</h2>

<p><code class="language-plaintext highlighter-rouge">train.py</code> 스크립트에서 실제 학습을 수행하는 과정을 구현하며, <code class="language-plaintext highlighter-rouge">test.py</code> 스크립트에서 테스트 데이터셋에 대해 학습이 완료된 모델을 테스트하여 성능 수치를 보여주고 실제로 Segmentation 마스크도 그려줍니다. 혹, 레이블이 없는 데이터셋에 대해서 그려보고 싶은 분들을 위해 <code class="language-plaintext highlighter-rouge">draw.py</code> 스크립트도 추가 구현하였으니 저장소에서 참고하시길 바랍니다.</p>

<h3 id="trainpy-스크립트">train.py 스크립트</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" 1. 원본 데이터셋을 메모리에 로드하고 분리함 """</span>
<span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">'data/catdog/'</span><span class="p">)</span> <span class="c1"># FIXME
</span><span class="n">trainval_dir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s">'train'</span><span class="p">)</span>

<span class="c1"># 앵커 로드
</span><span class="n">anchors</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">.</span><span class="n">load_json</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">trainval_dir</span><span class="p">,</span> <span class="s">'anchors.json'</span><span class="p">))</span>

<span class="c1"># 학습에 사용될 이미지 사이즈 및 클래스 개수를 정함
</span><span class="n">IM_SIZE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>
<span class="n">NUM_CLASSES</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># 원본 학습+검증 데이터셋을 로드하고, 이를 학습 데이터셋과 검증 데이터셋으로 나눔
</span><span class="n">X_trainval</span><span class="p">,</span> <span class="n">y_trainval</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">.</span><span class="n">read_data</span><span class="p">(</span><span class="n">trainval_dir</span><span class="p">,</span> <span class="n">IM_SIZE</span><span class="p">)</span>
<span class="n">trainval_size</span> <span class="o">=</span> <span class="n">X_trainval</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">val_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">trainval_size</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">)</span> <span class="c1"># FIXME
</span><span class="n">val_set</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">.</span><span class="n">DataSet</span><span class="p">(</span><span class="n">X_trainval</span><span class="p">[:</span><span class="n">val_size</span><span class="p">],</span> <span class="n">y_trainval</span><span class="p">[:</span><span class="n">val_size</span><span class="p">])</span>
<span class="n">train_set</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">.</span><span class="n">DataSet</span><span class="p">(</span><span class="n">X_trainval</span><span class="p">[</span><span class="n">val_size</span><span class="p">:],</span> <span class="n">y_trainval</span><span class="p">[</span><span class="n">val_size</span><span class="p">:])</span>

<span class="s">""" 2. 학습 수행 및 성능 평가를 위한 하이퍼파라미터 설정"""</span>
<span class="n">hp_d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<span class="c1"># FIXME: 학습 관련 하이퍼파라미터
</span><span class="n">hp_d</span><span class="p">[</span><span class="s">'batch_size'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">hp_d</span><span class="p">[</span><span class="s">'num_epochs'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">300</span>
<span class="n">hp_d</span><span class="p">[</span><span class="s">'init_learning_rate'</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-3</span>
<span class="n">hp_d</span><span class="p">[</span><span class="s">'momentum'</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">hp_d</span><span class="p">[</span><span class="s">'learning_rate_patience'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">hp_d</span><span class="p">[</span><span class="s">'learning_rate_decay'</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">hp_d</span><span class="p">[</span><span class="s">'eps'</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-8</span>
<span class="n">hp_d</span><span class="p">[</span><span class="s">'score_threshold'</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-4</span>
<span class="n">hp_d</span><span class="p">[</span><span class="s">'pretrain'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

<span class="s">""" 3. Graph 생성, session 초기화 및 학습 시작 """</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">get_default_graph</span><span class="p">()</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">ConfigProto</span><span class="p">()</span>
<span class="n">config</span><span class="p">.</span><span class="n">gpu_options</span><span class="p">.</span><span class="n">allow_growth</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">ConvNet</span><span class="p">([</span><span class="n">IM_SIZE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IM_SIZE</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">],</span> <span class="n">NUM_CLASSES</span><span class="p">,</span> <span class="o">**</span><span class="n">hp_d</span><span class="p">)</span>

<span class="n">evaluator</span> <span class="o">=</span> <span class="n">Evaluator</span><span class="p">()</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">Optimizer</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">train_set</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">,</span> <span class="n">val_set</span><span class="o">=</span><span class="n">val_set</span><span class="p">,</span> <span class="o">**</span><span class="n">hp_d</span><span class="p">)</span>

<span class="n">sess</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">Session</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>
<span class="n">train_results</span> <span class="o">=</span> <span class="n">optimizer</span><span class="p">.</span><span class="n">train</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">details</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">hp_d</span><span class="p">)</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">train.py</code> 스크립트에서는 마찬가지로 3단계로 진행됩니다.</p>

<ol>
  <li>원본 학습 데이터셋을 메모리에 로드하고, 이를 학습 데이터셋(90%)과 검증 데이터셋(10%)으로 나눠 객체 생성.</li>
  <li>학습 관련 하이퍼파라미터 설정.</li>
  <li><code class="language-plaintext highlighter-rouge">ConvNet</code> 객체, <code class="language-plaintext highlighter-rouge">Evaluator</code> 객체 및 <code class="language-plaintext highlighter-rouge">Optimizer</code> 객체를 생성하고, TensorFlow Graph와 Session을 초기화한 뒤, <code class="language-plaintext highlighter-rouge">Optimizer.train</code> 함수를 호출하여 모델 학습을 수행함</li>
</ol>

<ul>
  <li>원본 데이터셋 저장 경로, 하이퍼파라미터 등 <code class="language-plaintext highlighter-rouge">FIXME</code>로 표시된 부분은 여러분의 상황에 맞게 수정하시면 됩니다.</li>
</ul>

<h3 id="testpy-스크립트">test.py 스크립트</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">""" 1. 원본 데이터셋을 메모리에 로드함 """</span>
<span class="n">root_dir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="s">'data/catdog/'</span><span class="p">)</span>    <span class="c1"># FIXME
</span><span class="n">test_dir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s">'test'</span><span class="p">)</span>

<span class="c1"># 학습에 사용될 이미지 사이즈 및 클래스 개수를 정함
</span><span class="n">IM_SIZE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span>
<span class="n">NUM_CLASSES</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># 테스트 데이터셋을 로드함
</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">.</span><span class="n">read_data</span><span class="p">(</span><span class="n">test_dir</span><span class="p">,</span> <span class="n">IM_SIZE</span><span class="p">)</span>
<span class="n">test_set</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">.</span><span class="n">DataSet</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span>

<span class="s">""" 2. 테스트를 위한 하이퍼파라미터 설정 """</span>
<span class="n">hp_d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

<span class="c1"># FIXME
</span><span class="n">hp_d</span><span class="p">[</span><span class="s">'batch_size'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span>

<span class="s">""" 3. Graph 생성, 파라미터 로드, session 초기화 및 테스트 시작 """</span>
<span class="c1"># 초기화
</span><span class="n">graph</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">get_default_graph</span><span class="p">()</span>
<span class="n">config</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">ConfigProto</span><span class="p">()</span>
<span class="n">config</span><span class="p">.</span><span class="n">gpu_options</span><span class="p">.</span><span class="n">allow_growth</span> <span class="o">=</span> <span class="bp">True</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">ConvNet</span><span class="p">([</span><span class="n">IM_SIZE</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IM_SIZE</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">],</span> <span class="n">NUM_CLASSES</span><span class="p">,</span> <span class="o">**</span><span class="n">hp_d</span><span class="p">)</span>
<span class="n">evaluator</span> <span class="o">=</span> <span class="n">Evaluator</span><span class="p">()</span>
<span class="n">saver</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">train</span><span class="p">.</span><span class="n">Saver</span><span class="p">()</span>

<span class="n">sess</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">Session</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">)</span>
<span class="n">saver</span><span class="p">.</span><span class="n">restore</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="s">'./model.ckpt'</span><span class="p">)</span>    <span class="c1"># 학습한 weight 로드
</span><span class="n">test_y_pred</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">predict</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="n">test_set</span><span class="p">,</span> <span class="o">**</span><span class="n">hp_d</span><span class="p">)</span>
<span class="n">test_score</span> <span class="o">=</span> <span class="n">evaluator</span><span class="p">.</span><span class="n">score</span><span class="p">(</span><span class="n">test_set</span><span class="p">.</span><span class="n">labels</span><span class="p">,</span> <span class="n">test_y_pred</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">'Test performance: {}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">test_score</span><span class="p">))</span>

<span class="s">""" 4. 이미지 마스킹 """</span>
<span class="n">draw_dir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">test_dir</span><span class="p">,</span> <span class="s">'draws'</span><span class="p">)</span> <span class="c1"># FIXME
</span><span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">draw_dir</span><span class="p">):</span>
    <span class="n">os</span><span class="p">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">draw_dir</span><span class="p">)</span>
<span class="n">im_dir</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">test_dir</span><span class="p">,</span> <span class="s">'images'</span><span class="p">)</span> <span class="c1"># FIXME
</span><span class="n">im_paths</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">im_paths</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">glob</span><span class="p">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">im_dir</span><span class="p">,</span> <span class="s">'*.jpg'</span><span class="p">)))</span>
<span class="n">test_outputs</span> <span class="o">=</span> <span class="n">draw_pixel</span><span class="p">(</span><span class="n">test_y_pred</span><span class="p">)</span>
<span class="n">test_results</span> <span class="o">=</span> <span class="n">test_outputs</span> <span class="o">+</span> <span class="n">test_set</span><span class="p">.</span><span class="n">images</span>
<span class="k">for</span> <span class="n">img</span><span class="p">,</span> <span class="n">im_path</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">test_results</span><span class="p">,</span> <span class="n">im_paths</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">im_path</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'/'</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">draw_path</span> <span class="o">=</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">draw_dir</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
    <span class="n">cv2</span><span class="p">.</span><span class="n">imwrite</span><span class="p">(</span><span class="n">draw_path</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>

</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">test.py</code> 스크립트도 비슷하게 4단계 과정을 거쳐 성능을 측정하고 이미지에 예측된 마스크를 덧입혀 시각화하여 저장하였습니다.</p>

<h2 id="학습-결과-분석">학습 결과 분석</h2>

<h3 id="학습-곡선">학습 곡선</h3>

<p>Classification 문제때와 마찬가지로 학습 수행 과정동안 학습 곡선을 그려보았습니다.</p>

<!-- @reference: https://www.kevinmcgillivray.net/captions-for-images-with-jekyll/ -->
<p><a href="http://github.sualab.io/assets/images/image-segmentation-deep-learning/plot.png" target="_blank">
  <img class="large-image" src="http://github.sualab.io/assets/images/image-segmentation-deep-learning/plot.png" alt="학습 곡선 플롯팅 결과&lt;br&gt;&lt;small&gt;(파란색: 학습 데이터셋 정확도, 빨간색: 검증 데이터셋 정확도)&lt;/small&gt;" />
</a>
<span class="caption">학습 곡선 플롯팅 결과<br /><small>(파란색: 학습 데이터셋 정확도, 빨간색: 검증 데이터셋 정확도)</small></span></p>

<p>학습이 진행됨에 따라, Loss는 점차 떨어지고 성능 지표는 pretrained model을 사용해서 초반부터 높긴 하지만, 점차 올라가는 전형적인 학습 곡선 양상을 확인할 수 있었습니다. 검증 셋에 대해 가장 성능 지표가 높은 모델을 선택하고 이를 테스트셋에 대해 활용하여 테스트 성능을 다시 확인하였습니다.</p>

<h3 id="테스트-결과">테스트 결과</h3>

<p>테스트 결과 측정된 Pixel accuracy 값은 <strong>0.9556</strong>로 꽤 높은 값을 가졌습니다. 하지만 Pixel accuracy는 사용하는 데이터셋의 Foreground가 큰 경우에도 불구하고, 배경으로 모두 예측한 경우에도 꽤 높은 값을 가질 수 있기 때문에 값만 보고 추측하기는 어려울 때가 많습니다. 나중에 추가로 mIoU(mean Intersection over Union)등을 성능 지표로 삼고 다시 체크해보시길 추천드립니다. 돌아와서, 성능 값만 가지고 모델이 정말 잘 예측하는 지 신뢰하기 힘들기 때문에 실제 테스트 이미지에서 정말 객체 분할 및 분류를 잘했는지 확인하기 위하여 실제 이미지에 예측한 마스크를 시각화 해보았습니다.</p>

<!-- @reference: https://www.kevinmcgillivray.net/captions-for-images-with-jekyll/ -->
<p><a href="http://github.sualab.io/assets/images/image-segmentation-deep-learning/correct.png" target="_blank">
  <img class="full-image" src="http://github.sualab.io/assets/images/image-segmentation-deep-learning/correct.png" alt="정확하게 예측한 결과 예시" />
</a>
<span class="caption">정확하게 예측한 결과 예시</span></p>

<!-- @reference: https://www.kevinmcgillivray.net/captions-for-images-with-jekyll/ -->
<p><a href="http://github.sualab.io/assets/images/image-segmentation-deep-learning/incorrect.png" target="_blank">
  <img class="full-image" src="http://github.sualab.io/assets/images/image-segmentation-deep-learning/incorrect.png" alt="미흡하게 예측한 결과 예시" />
</a>
<span class="caption">미흡하게 예측한 결과 예시</span></p>

<p>대부분의 이미지에서 개 혹은 고양이 객체를 픽셀단위로 꽤 정확히 예측하였습니다. 하지만, 간혹 고양이가 카펫에 누워있거나, 배경이 헷갈리는 경우 배경까지 객체로 인식하는 경우 혹은 개를 고양이로, 고양이를 개로 인식하는 경우도 간혹가다 있었습니다. 이를 해결하기 위해 추가적인 Augmentation 기법이나 데이터를 늘리는 등 Fine-tuning을 거친다면 보다 더 좋은 결과를 낼 수 있다고 생각합니다!</p>

<h2 id="결론">결론</h2>

<p>본 포스팅에서는 이미지 인식 분야에서 중요하게 다뤄지는 Segmentation 문제를 응용할 수 있는 <strong>개vs고양이 분할 문제</strong> 사례를 소개하고 이를 GCN 모델과 TensorFlow를 이용한 딥러닝 알고리즘으로 해결하는 과정을 간단하게 안내해드렸습니다. 실제 Segmentation을 해야할 상황보다 쉬운 Task이기 때문에 엄밀하게 풀어냈다라고 할 수는 없지만, 실제 Segmentation 문제를 공부하고 처음 구현해보시는 분들에게는 약간이나마 도움이 됐을 것이라 생각합니다.</p>

<p>** 이로써 이미지 인식 분야에서 다뤄지는 세가지 문제(Classification, Detection, Segmentation)에 대해 간단한 데이터셋을 가지고 데이터 로드부터 구현 및 성능 체크과정까지 모두 다뤄보았습니다. 기획한 이미지 인식 분야 문제 해결과정에 대한 글은 여기서 마무리하지만, 그 외 딥러닝에 관한 글은 계속해서 블로그에 게시됩니다.</p>

<h2 id="references">References</h2>

<ul>
  <li>GCN 논문
    <ul>
      <li><a href="https://arxiv.org/abs/1703.02719" target="_blank">
Large Kernel Matters – Improve Semantic Segmentation by Global Convolutional Network</a></li>
    </ul>
  </li>
  <li>The Oxford-IIIT Pet Dataset
    <ul>
      <li><a href="http://www.robots.ox.ac.uk/~vgg/data/pets/" target="_blank">The Oxford-IIIT Pet Dataset</a></li>
    </ul>
  </li>
</ul>

  </div>

</article>

      </div>
    </main><footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Cognex Deep Learning Lab-KOR Research Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              Cognex Deep Learning Lab-KOR Research Blog
            
            </li>
            
            <li><a href="https://www.cognex.co.kr/" target="_blank">https://www.cognex.co.kr/</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          

          
          
          <li>
            <a href="https://facebook.com/cognexcorp" target="_blank"><i class="fa fa-facebook"></i> <span class="username">cognexcorp</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Cognex Deep Learning Lab-KOR research blog: covers subjects regarding machine learning, computer vision, high-performance computing, and so on.
</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
